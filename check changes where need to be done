#Panels <div>
library(leaflet)

#absolutePanel()
#conditionalPanel()
#fixedPanel()
#headerPanel()
#inputPanel()
#mainPanel()
#navListPanel()
#sidebarPanel()
#tabPanel()
#tabsetPanel()
#titlePanel()
#wellPanel()

# Layout: organize panels

# fluidRow()
# flowLayout()
# sidebarLayout()
# splitLayout()
# verticalLayout()


# inputs: buttons, file input, checkbox, date input, and more
shinyUI(
  fluidPage(padding=5,
  # Application title, separated by ,
  titlePanel(paste(sep=" ", "Bike sharing demand forecast from ", as.Date(Sys.Date()),
                   "to", (as.Date(Sys.Date())+5))), 
  # Define sidebar layout with 
  # sidebar panel and main panel
  sidebarLayout(
    mainPanel(
      leafletOutput("map", height=1000)
    ),
    sidebarPanel(
      selectInput(inputId="city_dropdown", label="Cities:",
                  choices = c("All", "Seoul",  "Osaka", "Washington", "Paris")),
      helpText("Select city from dropdown to show its bike prediction details: "),
      plotOutput("bike_line", height=300, click = "plot_click"),
      verbatimTextOutput("info"),
      plotOutput("temp_line", height=300),
      plotOutput("humidity_pred_chart", height=300),
    ))
))
=====================================================================================================
#server
library(shiny)
library(ggplot2)
library(leaflet)
library(tidyverse)
library(httr)
library(scales)
source("model_prediction.R")



generate_weather_data <- function(city_df) {
  
  weather_df <- predict_bike_rent_count(city_df$CITY_ASCII)

  weather_df <- weather_df %>% 
    select(CITY_ASCII, LABEL, DETAILED_LABEL, PREDICTION, TEMPERATURE, HUMIDITY, LEVEL, FORECASTDATETIME)
  city_df <- city_df %>% left_join(weather_df) %>% 
    select(CITY_ASCII, LNG, LAT, LABEL,DETAILED_LABEL,TEMPERATURE, PREDICTION, HUMIDITY, LEVEL, FORECASTDATETIME)
                
  return(city_df)
}


shinyServer(function(input, output){
  city_names <- c("Seoul",  "Osaka", "Washington", "Paris")
  city_info_df <- read_csv("world_cities.csv")
  
  # Observe city drop-down changes
  observeEvent(input$city_dropdown, {
    
    if(input$city_dropdown == 'All') {
      city_info_df <- city_info_df %>% 
        filter(CITY_ASCII %in% city_names)
      city_with_weather <- generate_weather_data(city_info_df)
      city_with_weather <- city_with_weather %>% 
        group_by(CITY_ASCII) %>% 
        slice(which.max(PREDICTION))
    }else {
      city_info_df <- city_info_df %>% 
        filter(CITY_ASCII == input$city_dropdown) %>% slice(1)
      city_with_weather <- generate_weather_data(city_info_df)
    }
    

    color_levels <- colorFactor(c("green", "yellow", "red"), 
                                levels = c("small", "medium", "large"))
    
    if(input$city_dropdown == 'All') {
      # Render a output plot with id
      output$map <- renderLeaflet({
          leaflet(data=city_with_weather, options = leafletOptions(minZoom = 1, maxZoom = 20)) %>%
            addTiles() %>% 
            addCircleMarkers(lng = ~LNG, lat = ~LAT, 
                             radius= ~ifelse(LEVEL=='small', 6, 12),
                             color = ~color_levels(LEVEL),
                             stroke = FALSE,
                             fillOpacity = 0.8,
                             label=~CITY_ASCII) %>%
            addPopups(lng = ~LNG, lat = ~LAT, popup=~LABEL,
                      options = popupOptions(closeButton = FALSE))
          })
    } else {

        selected_city <- city_with_weather %>% slice(1)
      
        output$map <- renderLeaflet({
          leaflet(data=selected_city)  %>% 
            addTiles() %>% 
            addMarkers(lng = ~LNG, lat = ~LAT) %>%
            addPopups(lng = ~LNG, lat = ~LAT, popup=~DETAILED_LABEL,
                      options = popupOptions(closeButton = FALSE))
        })

        output$bike_line <- renderPlot({
        line_plot<- ggplot(city_with_weather, aes(x=as.POSIXct(FORECASTDATETIME, "%Y-%m-%d %H:%M",tz="EST"), 
                                                  y=PREDICTION)) +  
        geom_point() + 
        geom_text(aes(label=PREDICTION),hjust=0, vjust=0) +
        geom_line(color="#69b3a2", size=1, alpha=0.9, linetype=2) + 
        scale_x_datetime(labels = scales::time_format("%m-%d-%H")) + 
        labs(x = "Time (3 hours ahead)", y ="Predicted Bike Count")
        line_plot
      })
      
      
      output$info <- renderText({
        paste0("Time=", as.POSIXct(as.integer(input$plot_click$x), origin = "1970-01-01"),
               "\nBikeCountPred=", as.integer(input$plot_click$y))
      })
      
      output$temp_line <- renderPlot({
        line_plot<- ggplot(city_with_weather, aes(x=1:length(TEMPERATURE), y=TEMPERATURE)) +
          geom_line(size=2) +  labs(x = "Time (3 hours ahead)", y ="TEMPERATURE (C)")
        ggtitle("TEMPERATURE Chart")
        line_plot
      })
      
      output$humidity_pred_chart <- renderPlot({
        line_plot<- ggplot(data=city_with_weather, aes(HUMIDITY, PREDICTION)) + 
          geom_point() +
          geom_smooth(method = "lm", formula = y ~ poly(x, 4), color="red")
        line_plot    
      })
    
    }
  })
  
})
======================================================================================================================
#model_prediction.R
library(ggplot2)
library(tidyverse)
library(httr)

# read the model back
load_saved_model <- function(model_name){
  model <- read_csv(model_name)
  model <- model %>% 
    mutate(Variable = gsub('"', '', Variable))
  coefs <- setNames(model$Coef, as.list(model$Variable))
  return(coefs)
}


get_weather_forecaset_by_cities <- function(city_names){
  city <- c()
  weather <- c()
  temperature <- c()
  visibility <- c()
  humidity <- c()
  wind_speed <- c()
  seasons <- c()
  hours <- c()
  forecast_date <-c()
  weather_labels<-c()
  weather_details_labels<-c()
  
  # Create some empty vectors to hold data temporarily
  for (city_name in city_names){
    url_get='https://api.openweathermap.org/data/2.5/forecast'
    forecast_query <- list(q = city_name, appid = "eeadb0857cce348954f4217a0e6fd15c", units="metric")
    response <- GET(url_get, query=forecast_query)
    json_list <-content(response, as="parsed")
    results <- json_list$list
    
    for(result in results) {
      
      city <- c(city, city_name)
      weather <- c(weather, result$weather[[1]]$main)
   
      # Get predictor variables
      temperature <- c(temperature, result$main$temp)
      visibility <- c(visibility, result$visibility)
      humidity <- c(humidity, result$main$humidity)
      wind_speed <- c(wind_speed, result$wind$speed)
      
      forecast_datetime <- result$dt_txt
      hour <- as.numeric(strftime(forecast_datetime, format="%H"))
      month <- as.numeric(strftime(forecast_datetime, format="%m"))
      forecast_date <-c(forecast_date, forecast_datetime)
      season <- "Spring"
      if (month >= 3 && month <= 5)
        season <- "SPRING"
      else if(month >= 6  &&  month <= 8)
        season <- "SUMMER"
      else if (month >= 9  && month <= 11)
        season <- "AUTUMN"
      else
        season <- "WINTER"
      
      weather_label <- paste(sep = "",
                             "<b><a href=''>",
                             city_name, 
                             "</a></b>", "</br>", 
                              "<b>", result$weather[[1]]$main, "</b></br>")
      weather_detail_label <- paste(sep = "",
                                      "<b><a href=''>",
                                      city_name, 
                                      "</a></b>", "</br>", 
                                      "<b>", result$weather[[1]]$main, "</b></br>",
                                      "Temperature: ", result$main$temp, " C </br>",
                                      "Visibility: ", result$visibility, " m </br>",
                                      "Humidity: ", result$main$humidity, " % </br>", 
                                      "Wind Speed: ", result$wind$speed, " m/s </br>", 
                                      "Datetime: ", forecast_datetime, " </br>")
      weather_labels <- c(weather_labels, weather_label)
      weather_details_labels <- c(weather_details_labels, weather_detail_label)
      
      seasons <- c(seasons, season)
      hours <- c(hours, hour)
      
    }
    
  }
  
  weather_df <- tibble(CITY_ASCII=city, WEATHER=weather, 
                   TEMPERATURE=temperature,
                   VISIBILITY=visibility, 
                   HUMIDITY=humidity, 
                   WIND_SPEED=wind_speed, SEASONS=season, HOURS=hours, FORECASTDATETIME=forecast_date, 
                   LABEL=weather_labels, DETAILED_LABEL=weather_details_labels)
  
  return(weather_df)
  
}



make_pred <- function(TEMPERATURE, HUMIDITY, WIND_SPEED, VISIBILITY, SEASONS, HOURS){
  model <- load_saved_model("model.csv")
  weather_terms <- model['Intercept'] + TEMPERATURE*model['TEMPERATURE'] + HUMIDITY*model['HUMIDITY'] +
    WIND_SPEED*model['WIND_SPEED'] + VISIBILITY*model['VISIBILITY'] 
  season_terms <- c()
  hour_terms <- c()
  for(season in SEASONS) {
    season_term <- switch(season, 'SPRING'=model['SPRING'],'SUMMER'=model['SUMMER'],
                          'AUTUMN'=model['AUTUMN'], 'WINTER'=model['WINTER'])
    season_terms <- c(season_terms, season_term)
  }
  #hours
  for(hour in HOURS){
    
    hour_term<- switch(as.character(hour),'0'=model['0'],'1'=model['1'],'2'=model['2'],'3'=model['3'],
                  '4'=model['4'],'5'=model['5'],'6'=model['6'],'7'=model['7'],
                  '8'=model['8'],'9'=model['9'],'10'=model['10'],'11'=model['11'],
                  '12'=model['12'],'13'=model['13'],'14'=model['14'],'15'=model['15'],'16'=model['16'],
                  '17'=model['17'],'18'=model['18'],'19'=model['19'],'20'=model['20'],
                  '21'=model['21'],'22'=model['22'],'23'=model['23'])
    hour_terms <- c(hour_terms, hour_term)
    
  }
  
  return(as.integer(weather_terms + season_terms + hour_terms))     

}

calculate_level<- function(predictions) {
  levels <- c()
  for(prediction in predictions){
     if(prediction <= 1000 && prediction > 0)
        levels <- c(levels, 'small')
     else if (prediction > 1000 && prediction < 3000)
        levels <- c(levels, 'medium')
     else
        levels <- c(levels, 'large')
  }
  return(levels)
}

predict_bike_rent_count <- function (cities){
 weather_df <- get_weather_forecaset_by_cities(cities)
 results <- weather_df %>% 
                mutate(PREDICTION=make_pred(TEMPERATURE, HUMIDITY, WIND_SPEED, VISIBILITY, SEASONS, HOURS)) %>%
                mutate(LEVEL=calculate_level(PREDICTION))
      
}
